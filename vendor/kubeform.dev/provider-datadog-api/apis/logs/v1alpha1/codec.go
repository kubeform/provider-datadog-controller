/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecAzureArchive{}).Type1()):                                                     ArchiveSpecAzureArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecGcsArchive{}).Type1()):                                                       ArchiveSpecGcsArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecS3Archive{}).Type1()):                                                        ArchiveSpecS3ArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorArithmeticProcessor{}).Type1()):                              CustomPipelineSpecProcessorArithmeticProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorAttributeRemapper{}).Type1()):                                CustomPipelineSpecProcessorAttributeRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessor{}).Type1()):                                CustomPipelineSpecProcessorCategoryProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}).Type1()):                  CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorDateRemapper{}).Type1()):                                     CustomPipelineSpecProcessorDateRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGeoIPParser{}).Type1()):                                      CustomPipelineSpecProcessorGeoIPParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParser{}).Type1()):                                       CustomPipelineSpecProcessorGrokParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParserGrok{}).Type1()):                                   CustomPipelineSpecProcessorGrokParserGrokCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorLookupProcessor{}).Type1()):                                  CustomPipelineSpecProcessorLookupProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorMessageRemapper{}).Type1()):                                  CustomPipelineSpecProcessorMessageRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipeline{}).Type1()):                                         CustomPipelineSpecProcessorPipelineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}).Type1()):             CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}).Type1()):               CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}).Type1()):               CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}).Type1()): CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}).Type1()):                    CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}).Type1()):                     CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParser{}).Type1()):                      CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}).Type1()):                  CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}).Type1()):                  CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}).Type1()):          CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUrlParser{}).Type1()):                       CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorServiceRemapper{}).Type1()):                                  CustomPipelineSpecProcessorServiceRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStatusRemapper{}).Type1()):                                   CustomPipelineSpecProcessorStatusRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStringBuilderProcessor{}).Type1()):                           CustomPipelineSpecProcessorStringBuilderProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorTraceIDRemapper{}).Type1()):                                  CustomPipelineSpecProcessorTraceIDRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUrlParser{}).Type1()):                                        CustomPipelineSpecProcessorUrlParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUserAgentParser{}).Type1()):                                  CustomPipelineSpecProcessorUserAgentParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IndexSpecFilter{}).Type1()):                                                             IndexSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecCompute{}).Type1()):                                                           MetricSpecComputeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecFilter{}).Type1()):                                                            MetricSpecFilterCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecAzureArchive{}).Type1()):                                                     ArchiveSpecAzureArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecGcsArchive{}).Type1()):                                                       ArchiveSpecGcsArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecS3Archive{}).Type1()):                                                        ArchiveSpecS3ArchiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorArithmeticProcessor{}).Type1()):                              CustomPipelineSpecProcessorArithmeticProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorAttributeRemapper{}).Type1()):                                CustomPipelineSpecProcessorAttributeRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessor{}).Type1()):                                CustomPipelineSpecProcessorCategoryProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}).Type1()):                  CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorDateRemapper{}).Type1()):                                     CustomPipelineSpecProcessorDateRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGeoIPParser{}).Type1()):                                      CustomPipelineSpecProcessorGeoIPParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParser{}).Type1()):                                       CustomPipelineSpecProcessorGrokParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParserGrok{}).Type1()):                                   CustomPipelineSpecProcessorGrokParserGrokCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorLookupProcessor{}).Type1()):                                  CustomPipelineSpecProcessorLookupProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorMessageRemapper{}).Type1()):                                  CustomPipelineSpecProcessorMessageRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipeline{}).Type1()):                                         CustomPipelineSpecProcessorPipelineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}).Type1()):             CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}).Type1()):               CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}).Type1()):               CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}).Type1()): CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}).Type1()):                    CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}).Type1()):                     CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParser{}).Type1()):                      CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}).Type1()):                  CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}).Type1()):                  CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}).Type1()):          CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUrlParser{}).Type1()):                       CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}).Type1()):                 CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorServiceRemapper{}).Type1()):                                  CustomPipelineSpecProcessorServiceRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStatusRemapper{}).Type1()):                                   CustomPipelineSpecProcessorStatusRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStringBuilderProcessor{}).Type1()):                           CustomPipelineSpecProcessorStringBuilderProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorTraceIDRemapper{}).Type1()):                                  CustomPipelineSpecProcessorTraceIDRemapperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUrlParser{}).Type1()):                                        CustomPipelineSpecProcessorUrlParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUserAgentParser{}).Type1()):                                  CustomPipelineSpecProcessorUserAgentParserCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IndexSpecFilter{}).Type1()):                                                             IndexSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecCompute{}).Type1()):                                                           MetricSpecComputeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecFilter{}).Type1()):                                                            MetricSpecFilterCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ArchiveSpecAzureArchiveCodec struct {
}

func (ArchiveSpecAzureArchiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ArchiveSpecAzureArchive)(ptr) == nil
}

func (ArchiveSpecAzureArchiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ArchiveSpecAzureArchive)(ptr)
	var objs []ArchiveSpecAzureArchive
	if obj != nil {
		objs = []ArchiveSpecAzureArchive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecAzureArchive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ArchiveSpecAzureArchiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ArchiveSpecAzureArchive)(ptr) = ArchiveSpecAzureArchive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ArchiveSpecAzureArchive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecAzureArchive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ArchiveSpecAzureArchive)(ptr) = objs[0]
			} else {
				*(*ArchiveSpecAzureArchive)(ptr) = ArchiveSpecAzureArchive{}
			}
		} else {
			*(*ArchiveSpecAzureArchive)(ptr) = ArchiveSpecAzureArchive{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ArchiveSpecAzureArchive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecAzureArchive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ArchiveSpecAzureArchive)(ptr) = obj
		} else {
			*(*ArchiveSpecAzureArchive)(ptr) = ArchiveSpecAzureArchive{}
		}
	default:
		iter.ReportError("decode ArchiveSpecAzureArchive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ArchiveSpecGcsArchiveCodec struct {
}

func (ArchiveSpecGcsArchiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ArchiveSpecGcsArchive)(ptr) == nil
}

func (ArchiveSpecGcsArchiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ArchiveSpecGcsArchive)(ptr)
	var objs []ArchiveSpecGcsArchive
	if obj != nil {
		objs = []ArchiveSpecGcsArchive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecGcsArchive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ArchiveSpecGcsArchiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ArchiveSpecGcsArchive)(ptr) = ArchiveSpecGcsArchive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ArchiveSpecGcsArchive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecGcsArchive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ArchiveSpecGcsArchive)(ptr) = objs[0]
			} else {
				*(*ArchiveSpecGcsArchive)(ptr) = ArchiveSpecGcsArchive{}
			}
		} else {
			*(*ArchiveSpecGcsArchive)(ptr) = ArchiveSpecGcsArchive{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ArchiveSpecGcsArchive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecGcsArchive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ArchiveSpecGcsArchive)(ptr) = obj
		} else {
			*(*ArchiveSpecGcsArchive)(ptr) = ArchiveSpecGcsArchive{}
		}
	default:
		iter.ReportError("decode ArchiveSpecGcsArchive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ArchiveSpecS3ArchiveCodec struct {
}

func (ArchiveSpecS3ArchiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ArchiveSpecS3Archive)(ptr) == nil
}

func (ArchiveSpecS3ArchiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ArchiveSpecS3Archive)(ptr)
	var objs []ArchiveSpecS3Archive
	if obj != nil {
		objs = []ArchiveSpecS3Archive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecS3Archive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ArchiveSpecS3ArchiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ArchiveSpecS3Archive)(ptr) = ArchiveSpecS3Archive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ArchiveSpecS3Archive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecS3Archive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ArchiveSpecS3Archive)(ptr) = objs[0]
			} else {
				*(*ArchiveSpecS3Archive)(ptr) = ArchiveSpecS3Archive{}
			}
		} else {
			*(*ArchiveSpecS3Archive)(ptr) = ArchiveSpecS3Archive{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ArchiveSpecS3Archive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ArchiveSpecS3Archive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ArchiveSpecS3Archive)(ptr) = obj
		} else {
			*(*ArchiveSpecS3Archive)(ptr) = ArchiveSpecS3Archive{}
		}
	default:
		iter.ReportError("decode ArchiveSpecS3Archive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorArithmeticProcessorCodec struct {
}

func (CustomPipelineSpecProcessorArithmeticProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorArithmeticProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorArithmeticProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorArithmeticProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorArithmeticProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorArithmeticProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorArithmeticProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorArithmeticProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorArithmeticProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorArithmeticProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorArithmeticProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorArithmeticProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorArithmeticProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorArithmeticProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorArithmeticProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorArithmeticProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorAttributeRemapperCodec struct {
}

func (CustomPipelineSpecProcessorAttributeRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorAttributeRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorAttributeRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorAttributeRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorAttributeRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorAttributeRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorAttributeRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorAttributeRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorAttributeRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorAttributeRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorAttributeRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorAttributeRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorAttributeRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorAttributeRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorAttributeRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorAttributeRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorAttributeRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorCategoryProcessorCodec struct {
}

func (CustomPipelineSpecProcessorCategoryProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorCategoryProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorCategoryProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorCategoryProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorCategoryProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorCategoryProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorCategoryProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorCategoryProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorCategoryProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorCategoryProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorCategoryProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorCategoryProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorCategoryProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorCategoryProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec struct {
}

func (CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) == nil
}

func (CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr)
	var objs []CustomPipelineSpecProcessorCategoryProcessorCategoryFilter
	if obj != nil {
		objs = []CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorCategoryProcessorCategoryFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorCategoryProcessorCategoryFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}
			}
		} else {
			*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorCategoryProcessorCategoryFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorCategoryProcessorCategoryFilter{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorCategoryProcessorCategoryFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorDateRemapperCodec struct {
}

func (CustomPipelineSpecProcessorDateRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorDateRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorDateRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorDateRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorDateRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorDateRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorDateRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorDateRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorDateRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorDateRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorDateRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorDateRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorDateRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorDateRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorDateRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorDateRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorDateRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorGeoIPParserCodec struct {
}

func (CustomPipelineSpecProcessorGeoIPParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorGeoIPParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorGeoIPParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorGeoIPParser)(ptr)
	var objs []CustomPipelineSpecProcessorGeoIPParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorGeoIPParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGeoIPParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorGeoIPParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorGeoIPParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorGeoIPParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGeoIPParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorGeoIPParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorGeoIPParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorGeoIPParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGeoIPParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorGeoIPParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorGeoIPParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorGrokParserCodec struct {
}

func (CustomPipelineSpecProcessorGrokParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorGrokParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorGrokParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorGrokParser)(ptr)
	var objs []CustomPipelineSpecProcessorGrokParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorGrokParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorGrokParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorGrokParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorGrokParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorGrokParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorGrokParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorGrokParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorGrokParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorGrokParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorGrokParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorGrokParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorGrokParserGrokCodec struct {
}

func (CustomPipelineSpecProcessorGrokParserGrokCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorGrokParserGrok)(ptr) == nil
}

func (CustomPipelineSpecProcessorGrokParserGrokCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorGrokParserGrok)(ptr)
	var objs []CustomPipelineSpecProcessorGrokParserGrok
	if obj != nil {
		objs = []CustomPipelineSpecProcessorGrokParserGrok{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParserGrok{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorGrokParserGrokCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorGrokParserGrok{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorGrokParserGrok

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParserGrok{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorGrokParserGrok{}
			}
		} else {
			*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorGrokParserGrok{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorGrokParserGrok

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorGrokParserGrok{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorGrokParserGrok{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorGrokParserGrok", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorLookupProcessorCodec struct {
}

func (CustomPipelineSpecProcessorLookupProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorLookupProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorLookupProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorLookupProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorLookupProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorLookupProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorLookupProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorLookupProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorLookupProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorLookupProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorLookupProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorLookupProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorLookupProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorLookupProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorLookupProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorLookupProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorLookupProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorMessageRemapperCodec struct {
}

func (CustomPipelineSpecProcessorMessageRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorMessageRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorMessageRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorMessageRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorMessageRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorMessageRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorMessageRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorMessageRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorMessageRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorMessageRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorMessageRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorMessageRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorMessageRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorMessageRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorMessageRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorMessageRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorMessageRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineCodec struct {
}

func (CustomPipelineSpecProcessorPipelineCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipeline)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipeline)(ptr)
	var objs []CustomPipelineSpecProcessorPipeline
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipeline{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipeline{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipeline)(ptr) = CustomPipelineSpecProcessorPipeline{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipeline

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipeline{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipeline)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipeline)(ptr) = CustomPipelineSpecProcessorPipeline{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipeline)(ptr) = CustomPipelineSpecProcessorPipeline{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipeline

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipeline{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipeline)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipeline)(ptr) = CustomPipelineSpecProcessorPipeline{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipeline", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorArithmeticProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorAttributeRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorAttributeRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorCategoryProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter)(ptr) = CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorCategoryProcessorCategoryFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorDateRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorDateRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorDateRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorDateRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorDateRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorDateRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorDateRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorDateRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorGeoIPParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorGeoIPParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorGeoIPParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorGeoIPParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGeoIPParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGeoIPParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorGeoIPParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorGrokParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorGrokParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorGrokParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorGrokParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorGrokParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorGrokParserGrokCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok)(ptr) = CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorGrokParserGrok", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorLookupProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorLookupProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorLookupProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorLookupProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorLookupProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorLookupProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorLookupProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorMessageRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorMessageRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorMessageRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorMessageRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorMessageRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorMessageRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorMessageRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorServiceRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorServiceRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorServiceRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorServiceRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorServiceRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorServiceRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorStatusRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorStatusRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorStatusRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorStatusRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStatusRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorStatusRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorStringBuilderProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorTraceIDRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorUrlParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorUrlParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUrlParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorUrlParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUrlParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorUrlParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUrlParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUrlParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUrlParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorUrlParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUrlParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUrlParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorUrlParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec struct {
}

func (CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr)
	var objs []CustomPipelineSpecProcessorPipelineProcessorUserAgentParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorPipelineProcessorUserAgentParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorPipelineProcessorUserAgentParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorPipelineProcessorUserAgentParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorPipelineProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorPipelineProcessorUserAgentParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorPipelineProcessorUserAgentParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorServiceRemapperCodec struct {
}

func (CustomPipelineSpecProcessorServiceRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorServiceRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorServiceRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorServiceRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorServiceRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorServiceRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorServiceRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorServiceRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorServiceRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorServiceRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorServiceRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorServiceRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorServiceRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorServiceRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorServiceRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorServiceRemapper)(ptr) = CustomPipelineSpecProcessorServiceRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorServiceRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorStatusRemapperCodec struct {
}

func (CustomPipelineSpecProcessorStatusRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorStatusRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorStatusRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorStatusRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorStatusRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorStatusRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStatusRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorStatusRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorStatusRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorStatusRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStatusRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorStatusRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorStatusRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorStatusRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStatusRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorStatusRemapper)(ptr) = CustomPipelineSpecProcessorStatusRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorStatusRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorStringBuilderProcessorCodec struct {
}

func (CustomPipelineSpecProcessorStringBuilderProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) == nil
}

func (CustomPipelineSpecProcessorStringBuilderProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr)
	var objs []CustomPipelineSpecProcessorStringBuilderProcessor
	if obj != nil {
		objs = []CustomPipelineSpecProcessorStringBuilderProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStringBuilderProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorStringBuilderProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorStringBuilderProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorStringBuilderProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStringBuilderProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorStringBuilderProcessor{}
			}
		} else {
			*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorStringBuilderProcessor{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorStringBuilderProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorStringBuilderProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorStringBuilderProcessor)(ptr) = CustomPipelineSpecProcessorStringBuilderProcessor{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorStringBuilderProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorTraceIDRemapperCodec struct {
}

func (CustomPipelineSpecProcessorTraceIDRemapperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) == nil
}

func (CustomPipelineSpecProcessorTraceIDRemapperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorTraceIDRemapper)(ptr)
	var objs []CustomPipelineSpecProcessorTraceIDRemapper
	if obj != nil {
		objs = []CustomPipelineSpecProcessorTraceIDRemapper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorTraceIDRemapper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorTraceIDRemapperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorTraceIDRemapper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorTraceIDRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorTraceIDRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorTraceIDRemapper{}
			}
		} else {
			*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorTraceIDRemapper{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorTraceIDRemapper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorTraceIDRemapper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorTraceIDRemapper)(ptr) = CustomPipelineSpecProcessorTraceIDRemapper{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorTraceIDRemapper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorUrlParserCodec struct {
}

func (CustomPipelineSpecProcessorUrlParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorUrlParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorUrlParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorUrlParser)(ptr)
	var objs []CustomPipelineSpecProcessorUrlParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorUrlParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUrlParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorUrlParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorUrlParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorUrlParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUrlParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorUrlParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorUrlParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorUrlParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorUrlParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUrlParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorUrlParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorUrlParser)(ptr) = CustomPipelineSpecProcessorUrlParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorUrlParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomPipelineSpecProcessorUserAgentParserCodec struct {
}

func (CustomPipelineSpecProcessorUserAgentParserCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomPipelineSpecProcessorUserAgentParser)(ptr) == nil
}

func (CustomPipelineSpecProcessorUserAgentParserCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomPipelineSpecProcessorUserAgentParser)(ptr)
	var objs []CustomPipelineSpecProcessorUserAgentParser
	if obj != nil {
		objs = []CustomPipelineSpecProcessorUserAgentParser{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUserAgentParser{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomPipelineSpecProcessorUserAgentParserCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorUserAgentParser{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomPipelineSpecProcessorUserAgentParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUserAgentParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = objs[0]
			} else {
				*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorUserAgentParser{}
			}
		} else {
			*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorUserAgentParser{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj CustomPipelineSpecProcessorUserAgentParser

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomPipelineSpecProcessorUserAgentParser{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = obj
		} else {
			*(*CustomPipelineSpecProcessorUserAgentParser)(ptr) = CustomPipelineSpecProcessorUserAgentParser{}
		}
	default:
		iter.ReportError("decode CustomPipelineSpecProcessorUserAgentParser", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IndexSpecFilterCodec struct {
}

func (IndexSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IndexSpecFilter)(ptr) == nil
}

func (IndexSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IndexSpecFilter)(ptr)
	var objs []IndexSpecFilter
	if obj != nil {
		objs = []IndexSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IndexSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IndexSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IndexSpecFilter)(ptr) = IndexSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IndexSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IndexSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IndexSpecFilter)(ptr) = objs[0]
			} else {
				*(*IndexSpecFilter)(ptr) = IndexSpecFilter{}
			}
		} else {
			*(*IndexSpecFilter)(ptr) = IndexSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj IndexSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IndexSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*IndexSpecFilter)(ptr) = obj
		} else {
			*(*IndexSpecFilter)(ptr) = IndexSpecFilter{}
		}
	default:
		iter.ReportError("decode IndexSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricSpecComputeCodec struct {
}

func (MetricSpecComputeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricSpecCompute)(ptr) == nil
}

func (MetricSpecComputeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricSpecCompute)(ptr)
	var objs []MetricSpecCompute
	if obj != nil {
		objs = []MetricSpecCompute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecCompute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricSpecComputeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricSpecCompute)(ptr) = MetricSpecCompute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricSpecCompute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecCompute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricSpecCompute)(ptr) = objs[0]
			} else {
				*(*MetricSpecCompute)(ptr) = MetricSpecCompute{}
			}
		} else {
			*(*MetricSpecCompute)(ptr) = MetricSpecCompute{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricSpecCompute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecCompute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricSpecCompute)(ptr) = obj
		} else {
			*(*MetricSpecCompute)(ptr) = MetricSpecCompute{}
		}
	default:
		iter.ReportError("decode MetricSpecCompute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricSpecFilterCodec struct {
}

func (MetricSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricSpecFilter)(ptr) == nil
}

func (MetricSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricSpecFilter)(ptr)
	var objs []MetricSpecFilter
	if obj != nil {
		objs = []MetricSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricSpecFilter)(ptr) = MetricSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricSpecFilter)(ptr) = objs[0]
			} else {
				*(*MetricSpecFilter)(ptr) = MetricSpecFilter{}
			}
		} else {
			*(*MetricSpecFilter)(ptr) = MetricSpecFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricSpecFilter)(ptr) = obj
		} else {
			*(*MetricSpecFilter)(ptr) = MetricSpecFilter{}
		}
	default:
		iter.ReportError("decode MetricSpecFilter", "unexpected JSON type")
	}
}
