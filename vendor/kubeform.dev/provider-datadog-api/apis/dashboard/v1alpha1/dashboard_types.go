/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Dashboard struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DashboardSpec   `json:"spec,omitempty"`
	Status            DashboardStatus `json:"status,omitempty"`
}

type DashboardSpecTemplateVariable struct {
	// The list of values that the template variable drop-down is be limited to
	// +optional
	AvailableValues []string `json:"availableValues,omitempty" tf:"available_values"`
	// The default value for the template variable on dashboard load.
	// +optional
	Default *string `json:"default,omitempty" tf:"default"`
	// The name of the variable.
	Name *string `json:"name" tf:"name"`
	// The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
	// +optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix"`
}

type DashboardSpecTemplateVariablePresetTemplateVariable struct {
	// The name of the template variable
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// The value that should be assumed by the template variable in this preset
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type DashboardSpecTemplateVariablePreset struct {
	// The name of the preset.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// The template variable names and assumed values under the given preset
	// +optional
	TemplateVariable []DashboardSpecTemplateVariablePresetTemplateVariable `json:"templateVariable,omitempty" tf:"template_variable"`
}

type DashboardSpecWidgetAlertGraphDefinition struct {
	// The ID of the monitor used by the widget.
	AlertID *string `json:"alertID" tf:"alert_id"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// Type of visualization to use when displaying the widget.
	VizType *string `json:"vizType" tf:"viz_type"`
}

type DashboardSpecWidgetAlertValueDefinition struct {
	// The ID of the monitor used by the widget.
	AlertID *string `json:"alertID" tf:"alert_id"`
	// The precision to use when displaying the value. Use `*` for maximum precision.
	// +optional
	Precision *int64 `json:"precision,omitempty" tf:"precision"`
	// The alignment of the text in the widget.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The unit for the value displayed in the widget.
	// +optional
	Unit *string `json:"unit,omitempty" tf:"unit"`
}

type DashboardSpecWidgetChangeDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetChangeDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetChangeDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetChangeDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetChangeDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetChangeDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetChangeDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetChangeDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetChangeDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetChangeDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetChangeDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetChangeDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetChangeDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetChangeDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetChangeDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetChangeDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetChangeDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetChangeDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetChangeDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetChangeDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetChangeDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetChangeDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetChangeDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetChangeDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetChangeDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetChangeDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// Whether to show absolute or relative change.
	// +optional
	ChangeType *string `json:"changeType,omitempty" tf:"change_type"`
	// Choose from when to compare current data to.
	// +optional
	CompareTo *string `json:"compareTo,omitempty" tf:"compare_to"`
	// A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
	// +optional
	IncreaseGood *bool `json:"increaseGood,omitempty" tf:"increase_good"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetChangeDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// What to order by.
	// +optional
	OrderBy *string `json:"orderBy,omitempty" tf:"order_by"`
	// Widget sorting method.
	// +optional
	OrderDir *string `json:"orderDir,omitempty" tf:"order_dir"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetChangeDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetChangeDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetChangeDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// If set to `true`, displays the current value.
	// +optional
	ShowPresent *bool `json:"showPresent,omitempty" tf:"show_present"`
}

type DashboardSpecWidgetChangeDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetChangeDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetChangeDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetCheckStatusDefinition struct {
	// The check to use in the widget.
	Check *string `json:"check" tf:"check"`
	// The check group to use in the widget.
	// +optional
	Group *string `json:"group,omitempty" tf:"group"`
	// When `grouping = "cluster"`, indicates a list of tags to use for grouping.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The kind of grouping to use.
	Grouping *string `json:"grouping" tf:"grouping"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A list of tags to use in the widget.
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetDistributionDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetDistributionDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetDistributionDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetDistributionDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetDistributionDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetDistributionDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetDistributionDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetDistributionDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetDistributionDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetDistributionDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetDistributionDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetDistributionDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetDistributionDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetDistributionDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetDistributionDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetDistributionDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetDistributionDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetDistributionDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetDistributionDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetDistributionDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetDistributionDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetDistributionDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetDistributionDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetDistributionDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetDistributionDefinition struct {
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetDistributionDefinitionRequest `json:"request,omitempty" tf:"request"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetEventStreamDefinition struct {
	// The size to use to display an event.
	// +optional
	EventSize *string `json:"eventSize,omitempty" tf:"event_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// The execution method for multi-value filters, options: `and` or `or`.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetEventTimelineDefinition struct {
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// The execution method for multi-value filters, options: `and` or `or`.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetFreeTextDefinition struct {
	// The color of the text in the widget.
	// +optional
	Color *string `json:"color,omitempty" tf:"color"`
	// The size of the text in the widget.
	// +optional
	FontSize *string `json:"fontSize,omitempty" tf:"font_size"`
	// The text to display in the widget.
	Text *string `json:"text" tf:"text"`
	// The alignment of the text in the widget.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
}

type DashboardSpecWidgetGeomapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGeomapDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGeomapDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGeomapDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGeomapDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGeomapDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGeomapDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGeomapDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGeomapDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGeomapDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGeomapDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGeomapDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGeomapDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGeomapDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGeomapDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGeomapDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGeomapDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGeomapDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGeomapDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGeomapDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGeomapDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGeomapDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGeomapDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGeomapDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGeomapDefinitionRequest struct {
	// +optional
	Formula []DashboardSpecWidgetGeomapDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGeomapDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGeomapDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGeomapDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
}

type DashboardSpecWidgetGeomapDefinitionStyle struct {
	// The color palette to apply to the widget.
	Palette *string `json:"palette" tf:"palette"`
	// A Boolean indicating whether to flip the palette tones.
	PaletteFlip *bool `json:"paletteFlip" tf:"palette_flip"`
}

type DashboardSpecWidgetGeomapDefinitionView struct {
	// The two-letter ISO code of a country to focus the map on (or `WORLD`).
	Focus *string `json:"focus" tf:"focus"`
}

type DashboardSpecWidgetGeomapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGeomapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGeomapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGeomapDefinitionStyle `json:"style,omitempty" tf:"style"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The view of the world that the map should render.
	View *DashboardSpecWidgetGeomapDefinitionView `json:"view" tf:"view"`
}

type DashboardSpecWidgetGroupDefinitionWidgetAlertGraphDefinition struct {
	// The ID of the monitor used by the widget.
	AlertID *string `json:"alertID" tf:"alert_id"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// Type of visualization to use when displaying the widget.
	VizType *string `json:"vizType" tf:"viz_type"`
}

type DashboardSpecWidgetGroupDefinitionWidgetAlertValueDefinition struct {
	// The ID of the monitor used by the widget.
	AlertID *string `json:"alertID" tf:"alert_id"`
	// The precision to use when displaying the value. Use `*` for maximum precision.
	// +optional
	Precision *int64 `json:"precision,omitempty" tf:"precision"`
	// The alignment of the text in the widget.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The unit for the value displayed in the widget.
	// +optional
	Unit *string `json:"unit,omitempty" tf:"unit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// Whether to show absolute or relative change.
	// +optional
	ChangeType *string `json:"changeType,omitempty" tf:"change_type"`
	// Choose from when to compare current data to.
	// +optional
	CompareTo *string `json:"compareTo,omitempty" tf:"compare_to"`
	// A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
	// +optional
	IncreaseGood *bool `json:"increaseGood,omitempty" tf:"increase_good"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// What to order by.
	// +optional
	OrderBy *string `json:"orderBy,omitempty" tf:"order_by"`
	// Widget sorting method.
	// +optional
	OrderDir *string `json:"orderDir,omitempty" tf:"order_dir"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// If set to `true`, displays the current value.
	// +optional
	ShowPresent *bool `json:"showPresent,omitempty" tf:"show_present"`
}

type DashboardSpecWidgetGroupDefinitionWidgetChangeDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetChangeDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetCheckStatusDefinition struct {
	// The check to use in the widget.
	Check *string `json:"check" tf:"check"`
	// The check group to use in the widget.
	// +optional
	Group *string `json:"group,omitempty" tf:"group"`
	// When `grouping = "cluster"`, indicates a list of tags to use for grouping.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The kind of grouping to use.
	Grouping *string `json:"grouping" tf:"grouping"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A list of tags to use in the widget.
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinition struct {
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinitionRequest `json:"request,omitempty" tf:"request"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetEventStreamDefinition struct {
	// The size to use to display an event.
	// +optional
	EventSize *string `json:"eventSize,omitempty" tf:"event_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// The execution method for multi-value filters, options: `and` or `or`.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetEventTimelineDefinition struct {
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// The execution method for multi-value filters, options: `and` or `or`.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetFreeTextDefinition struct {
	// The color of the text in the widget.
	// +optional
	Color *string `json:"color,omitempty" tf:"color"`
	// The size of the text in the widget.
	// +optional
	FontSize *string `json:"fontSize,omitempty" tf:"font_size"`
	// The text to display in the widget.
	Text *string `json:"text" tf:"text"`
	// The alignment of the text in the widget.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequest struct {
	// +optional
	Formula []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionStyle struct {
	// The color palette to apply to the widget.
	Palette *string `json:"palette" tf:"palette"`
	// A Boolean indicating whether to flip the palette tones.
	PaletteFlip *bool `json:"paletteFlip" tf:"palette_flip"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionView struct {
	// The two-letter ISO code of a country to focus the map on (or `WORLD`).
	Focus *string `json:"focus" tf:"focus"`
}

type DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionStyle `json:"style,omitempty" tf:"style"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The view of the world that the map should render.
	View *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinitionView `json:"view" tf:"view"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionEvent struct {
	// The event query to use in the widget.
	Q *string `json:"q" tf:"q"`
	// The execution method for multi-value filters.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
	// +optional
	Event []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionEvent `json:"event,omitempty" tf:"event"`
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the Y-Axis Controls. The structure of this block is described below.
	// +optional
	Yaxis *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequest struct {
	// The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Fill []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill `json:"fill,omitempty" tf:"fill"`
	// The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Size []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize `json:"size,omitempty" tf:"size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionStyle struct {
	// The max value to use to color the map.
	// +optional
	FillMax *string `json:"fillMax,omitempty" tf:"fill_max"`
	// The min value to use to color the map.
	// +optional
	FillMin *string `json:"fillMin,omitempty" tf:"fill_min"`
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
	// A Boolean indicating whether to flip the palette tones.
	// +optional
	PaletteFlip *bool `json:"paletteFlip,omitempty" tf:"palette_flip"`
}

type DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The list of tags to group nodes by.
	// +optional
	Group []string `json:"group,omitempty" tf:"group"`
	// A Boolean indicating whether to show ungrouped nodes.
	// +optional
	NoGroupHosts *bool `json:"noGroupHosts,omitempty" tf:"no_group_hosts"`
	// A Boolean indicating whether to show nodes with no metrics.
	// +optional
	NoMetricHosts *bool `json:"noMetricHosts,omitempty" tf:"no_metric_hosts"`
	// The type of node used.
	// +optional
	NodeType *string `json:"nodeType,omitempty" tf:"node_type"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
	// +optional
	Request *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The list of tags to filter nodes by.
	// +optional
	Scope []string `json:"scope,omitempty" tf:"scope"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinitionStyle `json:"style,omitempty" tf:"style"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetIframeDefinition struct {
	// The URL to use as a data source for the widget.
	Url *string `json:"url" tf:"url"`
}

type DashboardSpecWidgetGroupDefinitionWidgetImageDefinition struct {
	// Whether to display a background or not.
	// +optional
	HasBackground *bool `json:"hasBackground,omitempty" tf:"has_background"`
	// Whether to display a border or not.
	// +optional
	HasBorder *bool `json:"hasBorder,omitempty" tf:"has_border"`
	// The horizontal alignment for the widget.
	// +optional
	HorizontalAlign *string `json:"horizontalAlign,omitempty" tf:"horizontal_align"`
	// The margins to use around the image. Note: `small` and `large` values are deprecated.
	// +optional
	Margin *string `json:"margin,omitempty" tf:"margin"`
	// The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated.
	// +optional
	Sizing *string `json:"sizing,omitempty" tf:"sizing"`
	// The URL to use as a data source for the widget.
	Url *string `json:"url" tf:"url"`
	// The URL in dark mode to use as a data source for the widget.
	// +optional
	UrlDarkTheme *string `json:"urlDarkTheme,omitempty" tf:"url_dark_theme"`
	// The vertical alignment for the widget.
	// +optional
	VerticalAlign *string `json:"verticalAlign,omitempty" tf:"vertical_align"`
}

type DashboardSpecWidgetGroupDefinitionWidgetLogStreamDefinitionSort struct {
	// The facet path for the column
	Column *string `json:"column" tf:"column"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetLogStreamDefinition struct {
	// Stringified list of columns to use, for example: `["column1","column2","column3"]`.
	// +optional
	Columns []string `json:"columns,omitempty" tf:"columns"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The number of log lines to display.
	// +optional
	MessageDisplay *string `json:"messageDisplay,omitempty" tf:"message_display"`
	// The query to use in the widget.
	// +optional
	Query *string `json:"query,omitempty" tf:"query"`
	// If the date column should be displayed.
	// +optional
	ShowDateColumn *bool `json:"showDateColumn,omitempty" tf:"show_date_column"`
	// If the message column should be displayed.
	// +optional
	ShowMessageColumn *bool `json:"showMessageColumn,omitempty" tf:"show_message_column"`
	// The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetLogStreamDefinitionSort `json:"sort,omitempty" tf:"sort"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetManageStatusDefinition struct {
	// Whether to colorize text or background.
	// +optional
	ColorPreference *string `json:"colorPreference,omitempty" tf:"color_preference"`
	// The display setting to use.
	// +optional
	DisplayFormat *string `json:"displayFormat,omitempty" tf:"display_format"`
	// A Boolean indicating whether to hide empty categories.
	// +optional
	HideZeroCounts *bool `json:"hideZeroCounts,omitempty" tf:"hide_zero_counts"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// A Boolean indicating whether to show when monitors/groups last triggered.
	// +optional
	ShowLastTriggered *bool `json:"showLastTriggered,omitempty" tf:"show_last_triggered"`
	// The method to sort the monitors.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// The summary type to use.
	// +optional
	SummaryType *string `json:"summaryType,omitempty" tf:"summary_type"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetNoteDefinition struct {
	// The background color of the note.
	// +optional
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color"`
	// The content of the note.
	Content *string `json:"content" tf:"content"`
	// The size of the text.
	// +optional
	FontSize *string `json:"fontSize,omitempty" tf:"font_size"`
	// Whether to add padding or not.
	// +optional
	HasPadding *bool `json:"hasPadding,omitempty" tf:"has_padding"`
	// Whether to show a tick or not.
	// +optional
	ShowTick *bool `json:"showTick,omitempty" tf:"show_tick"`
	// The alignment of the widget's text.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// When `tick = true`, a string indicating on which side of the widget the tick should be displayed.
	// +optional
	TickEdge *string `json:"tickEdge,omitempty" tf:"tick_edge"`
	// When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
	// +optional
	TickPos *string `json:"tickPos,omitempty" tf:"tick_pos"`
	// The vertical alignment for the widget.
	// +optional
	VerticalAlign *string `json:"verticalAlign,omitempty" tf:"vertical_align"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns struct {
	// A user-assigned alias for the column.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// The column name.
	Name *string `json:"name" tf:"name"`
	// Widget sorting methods.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery struct {
	// Column properties used by the front end for display.
	// +optional
	Columns []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns `json:"columns,omitempty" tf:"columns"`
	// The environment name.
	Env *string `json:"env" tf:"env"`
	// The operation name associated with the service.
	Name *string `json:"name" tf:"name"`
	// The organization's host group name and value.
	PrimaryTag *string `json:"primaryTag" tf:"primary_tag"`
	// The resource name.
	// +optional
	Resource *string `json:"resource,omitempty" tf:"resource"`
	// The level of detail for the request.
	RowType *string `json:"rowType" tf:"row_type"`
	// The service name.
	Service *string `json:"service" tf:"service"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequest struct {
	// The aggregator to use for time aggregation.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The alias for the column name (defaults to metric name).
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// +optional
	ApmStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery `json:"apmStatsQuery,omitempty" tf:"apm_stats_query"`
	// A list of display modes for each table cell. List items one of `number`, `bar`.
	// +optional
	CellDisplayMode []string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The number of lines to show in the table.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The sort order for the rows.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// Controls the display of the search bar.
	// +optional
	HasSearchBar *string `json:"hasSearchBar,omitempty" tf:"has_search_bar"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequest struct {
	// The aggregator to use for time aggregation.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinition struct {
	// A Boolean indicating whether to automatically scale the tile.
	// +optional
	Autoscale *bool `json:"autoscale,omitempty" tf:"autoscale"`
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The unit for the value displayed in the widget.
	// +optional
	CustomUnit *string `json:"customUnit,omitempty" tf:"custom_unit"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The precision to use when displaying the tile.
	// +optional
	Precision *int64 `json:"precision,omitempty" tf:"precision"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The alignment of the widget's text.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX struct {
	// Aggregator used for the request.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY struct {
	// Aggregator used for the request.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequest struct {
	// The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
	// +optional
	X []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX `json:"x,omitempty" tf:"x"`
	// The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
	// +optional
	Y []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY `json:"y,omitempty" tf:"y"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinition struct {
	// List of groups used for colors.
	// +optional
	ColorByGroups []string `json:"colorByGroups,omitempty" tf:"color_by_groups"`
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
	// +optional
	Request *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
	// +optional
	Xaxis *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis `json:"xaxis,omitempty" tf:"xaxis"`
	// A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
	// +optional
	Yaxis *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition struct {
	// The global time target of the widget.
	// +optional
	GlobalTimeTarget *string `json:"globalTimeTarget,omitempty" tf:"global_time_target"`
	// Whether to show the error budget or not.
	// +optional
	ShowErrorBudget *bool `json:"showErrorBudget,omitempty" tf:"show_error_budget"`
	// The ID of the service level objective used by the widget.
	SloID *string `json:"sloID" tf:"slo_id"`
	// A list of time windows to display in the widget.
	TimeWindows []string `json:"timeWindows" tf:"time_windows"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The view mode for the widget.
	ViewMode *string `json:"viewMode" tf:"view_mode"`
	// The type of view to use when displaying the widget. Only `detail` is supported.
	ViewType *string `json:"viewType" tf:"view_type"`
}

type DashboardSpecWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetServicemapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// Your environment and primary tag (or `*` if enabled for your account).
	Filters []string `json:"filters" tf:"filters"`
	// The ID of the service to map.
	Service *string `json:"service" tf:"service"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent struct {
	// The event query to use in the widget.
	Q *string `json:"q" tf:"q"`
	// The execution method for multi-value filters.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker struct {
	// How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
	// +optional
	DisplayType *string `json:"displayType,omitempty" tf:"display_type"`
	// A label for the line or range.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
	Value *string `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata struct {
	// The expression alias.
	// +optional
	AliasName *string `json:"aliasName,omitempty" tf:"alias_name"`
	// The expression name.
	Expression *string `json:"expression" tf:"expression"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle struct {
	// The type of lines displayed.
	// +optional
	LineType *string `json:"lineType,omitempty" tf:"line_type"`
	// The width of line displayed.
	// +optional
	LineWidth *string `json:"lineWidth,omitempty" tf:"line_width"`
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// How to display the marker lines.
	// +optional
	DisplayType *string `json:"displayType,omitempty" tf:"display_type"`
	// +optional
	Formula []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
	// +optional
	Metadata []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata `json:"metadata,omitempty" tf:"metadata"`
	// The query to use for this widget.
	// +optional
	NetworkQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery `json:"networkQuery,omitempty" tf:"network_query"`
	// A Boolean indicating whether the request uses the right or left Y-Axis.
	// +optional
	OnRightYaxis *bool `json:"onRightYaxis,omitempty" tf:"on_right_yaxis"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. Exactly one `style` block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
	// +optional
	Event []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent `json:"event,omitempty" tf:"event"`
	// A list of columns to display in the legend.
	// +optional
	LegendColumns []string `json:"legendColumns,omitempty" tf:"legend_columns"`
	// The layout of the legend displayed in the widget.
	// +optional
	LegendLayout *string `json:"legendLayout,omitempty" tf:"legend_layout"`
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
	// +optional
	Marker []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker `json:"marker,omitempty" tf:"marker"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest `json:"request,omitempty" tf:"request"`
	// A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
	// +optional
	RightYaxis *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis `json:"rightYaxis,omitempty" tf:"right_yaxis"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the Y-Axis Controls. The structure of this block is described below
	// +optional
	Yaxis *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// Define request for the widget's style.
	// +optional
	Style *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetGroupDefinitionWidgetToplistDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetGroupDefinitionWidgetToplistDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetTraceServiceDefinition struct {
	// The number of columns to display.
	// +optional
	DisplayFormat *string `json:"displayFormat,omitempty" tf:"display_format"`
	// APM environment.
	Env *string `json:"env" tf:"env"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// Whether to show the latency breakdown or not.
	// +optional
	ShowBreakdown *bool `json:"showBreakdown,omitempty" tf:"show_breakdown"`
	// Whether to show the latency distribution or not.
	// +optional
	ShowDistribution *bool `json:"showDistribution,omitempty" tf:"show_distribution"`
	// Whether to show the error metrics or not.
	// +optional
	ShowErrors *bool `json:"showErrors,omitempty" tf:"show_errors"`
	// Whether to show the hits metrics or not
	// +optional
	ShowHits *bool `json:"showHits,omitempty" tf:"show_hits"`
	// Whether to show the latency metrics or not.
	// +optional
	ShowLatency *bool `json:"showLatency,omitempty" tf:"show_latency"`
	// Whether to show the resource list or not.
	// +optional
	ShowResourceList *bool `json:"showResourceList,omitempty" tf:"show_resource_list"`
	// The size of the widget.
	// +optional
	SizeFormat *string `json:"sizeFormat,omitempty" tf:"size_format"`
	// APM span name
	SpanName *string `json:"spanName" tf:"span_name"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetGroupDefinitionWidgetWidgetLayout struct {
	// The height of the widget.
	Height *int64 `json:"height" tf:"height"`
	// Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
	// +optional
	IsColumnBreak *bool `json:"isColumnBreak,omitempty" tf:"is_column_break"`
	// The width of the widget.
	Width *int64 `json:"width" tf:"width"`
	// The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
	X *int64 `json:"x" tf:"x"`
	// The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
	Y *int64 `json:"y" tf:"y"`
}

type DashboardSpecWidgetGroupDefinitionWidget struct {
	// The definition for a Alert Graph widget.
	// +optional
	AlertGraphDefinition *DashboardSpecWidgetGroupDefinitionWidgetAlertGraphDefinition `json:"alertGraphDefinition,omitempty" tf:"alert_graph_definition"`
	// The definition for a Alert Value widget.
	// +optional
	AlertValueDefinition *DashboardSpecWidgetGroupDefinitionWidgetAlertValueDefinition `json:"alertValueDefinition,omitempty" tf:"alert_value_definition"`
	// The definition for a Change widget.
	// +optional
	ChangeDefinition *DashboardSpecWidgetGroupDefinitionWidgetChangeDefinition `json:"changeDefinition,omitempty" tf:"change_definition"`
	// The definition for a Check Status widget.
	// +optional
	CheckStatusDefinition *DashboardSpecWidgetGroupDefinitionWidgetCheckStatusDefinition `json:"checkStatusDefinition,omitempty" tf:"check_status_definition"`
	// The definition for a Distribution widget.
	// +optional
	DistributionDefinition *DashboardSpecWidgetGroupDefinitionWidgetDistributionDefinition `json:"distributionDefinition,omitempty" tf:"distribution_definition"`
	// The definition for a Event Stream widget.
	// +optional
	EventStreamDefinition *DashboardSpecWidgetGroupDefinitionWidgetEventStreamDefinition `json:"eventStreamDefinition,omitempty" tf:"event_stream_definition"`
	// The definition for a Event Timeline widget.
	// +optional
	EventTimelineDefinition *DashboardSpecWidgetGroupDefinitionWidgetEventTimelineDefinition `json:"eventTimelineDefinition,omitempty" tf:"event_timeline_definition"`
	// The definition for a Free Text widget.
	// +optional
	FreeTextDefinition *DashboardSpecWidgetGroupDefinitionWidgetFreeTextDefinition `json:"freeTextDefinition,omitempty" tf:"free_text_definition"`
	// The definition for a Geomap widget.
	// +optional
	GeomapDefinition *DashboardSpecWidgetGroupDefinitionWidgetGeomapDefinition `json:"geomapDefinition,omitempty" tf:"geomap_definition"`
	// The definition for a Heatmap widget.
	// +optional
	HeatmapDefinition *DashboardSpecWidgetGroupDefinitionWidgetHeatmapDefinition `json:"heatmapDefinition,omitempty" tf:"heatmap_definition"`
	// The definition for a Hostmap widget.
	// +optional
	HostmapDefinition *DashboardSpecWidgetGroupDefinitionWidgetHostmapDefinition `json:"hostmapDefinition,omitempty" tf:"hostmap_definition"`
	// The ID of the widget.
	// +optional
	ID *int64 `json:"ID,omitempty" tf:"id"`
	// The definition for an Iframe widget.
	// +optional
	IframeDefinition *DashboardSpecWidgetGroupDefinitionWidgetIframeDefinition `json:"iframeDefinition,omitempty" tf:"iframe_definition"`
	// The definition for an Image widget
	// +optional
	ImageDefinition *DashboardSpecWidgetGroupDefinitionWidgetImageDefinition `json:"imageDefinition,omitempty" tf:"image_definition"`
	// The definition for an Log Stream widget.
	// +optional
	LogStreamDefinition *DashboardSpecWidgetGroupDefinitionWidgetLogStreamDefinition `json:"logStreamDefinition,omitempty" tf:"log_stream_definition"`
	// The definition for an Manage Status widget.
	// +optional
	ManageStatusDefinition *DashboardSpecWidgetGroupDefinitionWidgetManageStatusDefinition `json:"manageStatusDefinition,omitempty" tf:"manage_status_definition"`
	// The definition for a Note widget.
	// +optional
	NoteDefinition *DashboardSpecWidgetGroupDefinitionWidgetNoteDefinition `json:"noteDefinition,omitempty" tf:"note_definition"`
	// The definition for a Query Table widget.
	// +optional
	QueryTableDefinition *DashboardSpecWidgetGroupDefinitionWidgetQueryTableDefinition `json:"queryTableDefinition,omitempty" tf:"query_table_definition"`
	// The definition for a Query Value widget.
	// +optional
	QueryValueDefinition *DashboardSpecWidgetGroupDefinitionWidgetQueryValueDefinition `json:"queryValueDefinition,omitempty" tf:"query_value_definition"`
	// The definition for a Scatterplot widget.
	// +optional
	ScatterplotDefinition *DashboardSpecWidgetGroupDefinitionWidgetScatterplotDefinition `json:"scatterplotDefinition,omitempty" tf:"scatterplot_definition"`
	// The definition for a Service Level Objective widget.
	// +optional
	ServiceLevelObjectiveDefinition *DashboardSpecWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition `json:"serviceLevelObjectiveDefinition,omitempty" tf:"service_level_objective_definition"`
	// The definition for a Service Map widget.
	// +optional
	ServicemapDefinition *DashboardSpecWidgetGroupDefinitionWidgetServicemapDefinition `json:"servicemapDefinition,omitempty" tf:"servicemap_definition"`
	// The definition for a Timeseries widget.
	// +optional
	TimeseriesDefinition *DashboardSpecWidgetGroupDefinitionWidgetTimeseriesDefinition `json:"timeseriesDefinition,omitempty" tf:"timeseries_definition"`
	// The definition for a Toplist widget.
	// +optional
	ToplistDefinition *DashboardSpecWidgetGroupDefinitionWidgetToplistDefinition `json:"toplistDefinition,omitempty" tf:"toplist_definition"`
	// The definition for a Trace Service widget.
	// +optional
	TraceServiceDefinition *DashboardSpecWidgetGroupDefinitionWidgetTraceServiceDefinition `json:"traceServiceDefinition,omitempty" tf:"trace_service_definition"`
	// The layout of the widget on a 'free' dashboard.
	// +optional
	WidgetLayout *DashboardSpecWidgetGroupDefinitionWidgetWidgetLayout `json:"widgetLayout,omitempty" tf:"widget_layout"`
}

type DashboardSpecWidgetGroupDefinition struct {
	// The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
	// +optional
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color"`
	// The image URL to display as a banner for the group.
	// +optional
	BannerImg *string `json:"bannerImg,omitempty" tf:"banner_img"`
	// The layout type of the group.
	LayoutType *string `json:"layoutType" tf:"layout_type"`
	// Whether to show the title or not.
	// +optional
	ShowTitle *bool `json:"showTitle,omitempty" tf:"show_title"`
	// The title of the group.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The list of widgets in this group.
	Widget []DashboardSpecWidgetGroupDefinitionWidget `json:"widget" tf:"widget"`
}

type DashboardSpecWidgetHeatmapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetHeatmapDefinitionEvent struct {
	// The event query to use in the widget.
	Q *string `json:"q" tf:"q"`
	// The execution method for multi-value filters.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHeatmapDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHeatmapDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHeatmapDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHeatmapDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHeatmapDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHeatmapDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHeatmapDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHeatmapDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHeatmapDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHeatmapDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetHeatmapDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetHeatmapDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetHeatmapDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetHeatmapDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetHeatmapDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetHeatmapDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetHeatmapDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetHeatmapDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetHeatmapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetHeatmapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
	// +optional
	Event []DashboardSpecWidgetHeatmapDefinitionEvent `json:"event,omitempty" tf:"event"`
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Request []DashboardSpecWidgetHeatmapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the Y-Axis Controls. The structure of this block is described below.
	// +optional
	Yaxis *DashboardSpecWidgetHeatmapDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetHostmapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestFillApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestFillLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestFillRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestFill struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetHostmapDefinitionRequestFillApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetHostmapDefinitionRequestFillLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetHostmapDefinitionRequestFillProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetHostmapDefinitionRequestFillRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetHostmapDefinitionRequestFillSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequestSize struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetHostmapDefinitionRequestSizeSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetHostmapDefinitionRequest struct {
	// The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Fill []DashboardSpecWidgetHostmapDefinitionRequestFill `json:"fill,omitempty" tf:"fill"`
	// The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
	// +optional
	Size []DashboardSpecWidgetHostmapDefinitionRequestSize `json:"size,omitempty" tf:"size"`
}

type DashboardSpecWidgetHostmapDefinitionStyle struct {
	// The max value to use to color the map.
	// +optional
	FillMax *string `json:"fillMax,omitempty" tf:"fill_max"`
	// The min value to use to color the map.
	// +optional
	FillMin *string `json:"fillMin,omitempty" tf:"fill_min"`
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
	// A Boolean indicating whether to flip the palette tones.
	// +optional
	PaletteFlip *bool `json:"paletteFlip,omitempty" tf:"palette_flip"`
}

type DashboardSpecWidgetHostmapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetHostmapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The list of tags to group nodes by.
	// +optional
	Group []string `json:"group,omitempty" tf:"group"`
	// A Boolean indicating whether to show ungrouped nodes.
	// +optional
	NoGroupHosts *bool `json:"noGroupHosts,omitempty" tf:"no_group_hosts"`
	// A Boolean indicating whether to show nodes with no metrics.
	// +optional
	NoMetricHosts *bool `json:"noMetricHosts,omitempty" tf:"no_metric_hosts"`
	// The type of node used.
	// +optional
	NodeType *string `json:"nodeType,omitempty" tf:"node_type"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
	// +optional
	Request *DashboardSpecWidgetHostmapDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The list of tags to filter nodes by.
	// +optional
	Scope []string `json:"scope,omitempty" tf:"scope"`
	// The style of the widget graph. One nested block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetHostmapDefinitionStyle `json:"style,omitempty" tf:"style"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetIframeDefinition struct {
	// The URL to use as a data source for the widget.
	Url *string `json:"url" tf:"url"`
}

type DashboardSpecWidgetImageDefinition struct {
	// Whether to display a background or not.
	// +optional
	HasBackground *bool `json:"hasBackground,omitempty" tf:"has_background"`
	// Whether to display a border or not.
	// +optional
	HasBorder *bool `json:"hasBorder,omitempty" tf:"has_border"`
	// The horizontal alignment for the widget.
	// +optional
	HorizontalAlign *string `json:"horizontalAlign,omitempty" tf:"horizontal_align"`
	// The margins to use around the image. Note: `small` and `large` values are deprecated.
	// +optional
	Margin *string `json:"margin,omitempty" tf:"margin"`
	// The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated.
	// +optional
	Sizing *string `json:"sizing,omitempty" tf:"sizing"`
	// The URL to use as a data source for the widget.
	Url *string `json:"url" tf:"url"`
	// The URL in dark mode to use as a data source for the widget.
	// +optional
	UrlDarkTheme *string `json:"urlDarkTheme,omitempty" tf:"url_dark_theme"`
	// The vertical alignment for the widget.
	// +optional
	VerticalAlign *string `json:"verticalAlign,omitempty" tf:"vertical_align"`
}

type DashboardSpecWidgetLogStreamDefinitionSort struct {
	// The facet path for the column
	Column *string `json:"column" tf:"column"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetLogStreamDefinition struct {
	// Stringified list of columns to use, for example: `["column1","column2","column3"]`.
	// +optional
	Columns []string `json:"columns,omitempty" tf:"columns"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The number of log lines to display.
	// +optional
	MessageDisplay *string `json:"messageDisplay,omitempty" tf:"message_display"`
	// The query to use in the widget.
	// +optional
	Query *string `json:"query,omitempty" tf:"query"`
	// If the date column should be displayed.
	// +optional
	ShowDateColumn *bool `json:"showDateColumn,omitempty" tf:"show_date_column"`
	// If the message column should be displayed.
	// +optional
	ShowMessageColumn *bool `json:"showMessageColumn,omitempty" tf:"show_message_column"`
	// The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
	// +optional
	Sort *DashboardSpecWidgetLogStreamDefinitionSort `json:"sort,omitempty" tf:"sort"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetManageStatusDefinition struct {
	// Whether to colorize text or background.
	// +optional
	ColorPreference *string `json:"colorPreference,omitempty" tf:"color_preference"`
	// The display setting to use.
	// +optional
	DisplayFormat *string `json:"displayFormat,omitempty" tf:"display_format"`
	// A Boolean indicating whether to hide empty categories.
	// +optional
	HideZeroCounts *bool `json:"hideZeroCounts,omitempty" tf:"hide_zero_counts"`
	// The query to use in the widget.
	Query *string `json:"query" tf:"query"`
	// A Boolean indicating whether to show when monitors/groups last triggered.
	// +optional
	ShowLastTriggered *bool `json:"showLastTriggered,omitempty" tf:"show_last_triggered"`
	// The method to sort the monitors.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// The summary type to use.
	// +optional
	SummaryType *string `json:"summaryType,omitempty" tf:"summary_type"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetNoteDefinition struct {
	// The background color of the note.
	// +optional
	BackgroundColor *string `json:"backgroundColor,omitempty" tf:"background_color"`
	// The content of the note.
	Content *string `json:"content" tf:"content"`
	// The size of the text.
	// +optional
	FontSize *string `json:"fontSize,omitempty" tf:"font_size"`
	// Whether to add padding or not.
	// +optional
	HasPadding *bool `json:"hasPadding,omitempty" tf:"has_padding"`
	// Whether to show a tick or not.
	// +optional
	ShowTick *bool `json:"showTick,omitempty" tf:"show_tick"`
	// The alignment of the widget's text.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// When `tick = true`, a string indicating on which side of the widget the tick should be displayed.
	// +optional
	TickEdge *string `json:"tickEdge,omitempty" tf:"tick_edge"`
	// When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
	// +optional
	TickPos *string `json:"tickPos,omitempty" tf:"tick_pos"`
	// The vertical alignment for the widget.
	// +optional
	VerticalAlign *string `json:"verticalAlign,omitempty" tf:"vertical_align"`
}

type DashboardSpecWidgetQueryTableDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryTableDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryTableDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryTableDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmStatsQueryColumns struct {
	// A user-assigned alias for the column.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// The column name.
	Name *string `json:"name" tf:"name"`
	// Widget sorting methods.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestApmStatsQuery struct {
	// Column properties used by the front end for display.
	// +optional
	Columns []DashboardSpecWidgetQueryTableDefinitionRequestApmStatsQueryColumns `json:"columns,omitempty" tf:"columns"`
	// The environment name.
	Env *string `json:"env" tf:"env"`
	// The operation name associated with the service.
	Name *string `json:"name" tf:"name"`
	// The organization's host group name and value.
	PrimaryTag *string `json:"primaryTag" tf:"primary_tag"`
	// The resource name.
	// +optional
	Resource *string `json:"resource,omitempty" tf:"resource"`
	// The level of detail for the request.
	RowType *string `json:"rowType" tf:"row_type"`
	// The service name.
	Service *string `json:"service" tf:"service"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetQueryTableDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetQueryTableDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryTableDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryTableDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryTableDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetQueryTableDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetQueryTableDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetQueryTableDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryTableDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryTableDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryTableDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryTableDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryTableDefinitionRequest struct {
	// The aggregator to use for time aggregation.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The alias for the column name (defaults to metric name).
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetQueryTableDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// +optional
	ApmStatsQuery *DashboardSpecWidgetQueryTableDefinitionRequestApmStatsQuery `json:"apmStatsQuery,omitempty" tf:"apm_stats_query"`
	// A list of display modes for each table cell. List items one of `number`, `bar`.
	// +optional
	CellDisplayMode []string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetQueryTableDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetQueryTableDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The number of lines to show in the table.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetQueryTableDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The sort order for the rows.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetQueryTableDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetQueryTableDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetQueryTableDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetQueryTableDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetQueryTableDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetQueryTableDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// Controls the display of the search bar.
	// +optional
	HasSearchBar *string `json:"hasSearchBar,omitempty" tf:"has_search_bar"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetQueryTableDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetQueryValueDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryValueDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryValueDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryValueDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetQueryValueDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetQueryValueDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryValueDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryValueDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetQueryValueDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetQueryValueDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetQueryValueDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryValueDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryValueDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetQueryValueDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetQueryValueDefinitionRequest struct {
	// The aggregator to use for time aggregation.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetQueryValueDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetQueryValueDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetQueryValueDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetQueryValueDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetQueryValueDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetQueryValueDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetQueryValueDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetQueryValueDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetQueryValueDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetQueryValueDefinition struct {
	// A Boolean indicating whether to automatically scale the tile.
	// +optional
	Autoscale *bool `json:"autoscale,omitempty" tf:"autoscale"`
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetQueryValueDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The unit for the value displayed in the widget.
	// +optional
	CustomUnit *string `json:"customUnit,omitempty" tf:"custom_unit"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// The precision to use when displaying the tile.
	// +optional
	Precision *int64 `json:"precision,omitempty" tf:"precision"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetQueryValueDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The alignment of the widget's text.
	// +optional
	TextAlign *string `json:"textAlign,omitempty" tf:"text_align"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetScatterplotDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestXApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestXLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestXRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestX struct {
	// Aggregator used for the request.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetScatterplotDefinitionRequestXApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetScatterplotDefinitionRequestXLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetScatterplotDefinitionRequestXProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetScatterplotDefinitionRequestXRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetScatterplotDefinitionRequestXSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestYApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestYLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestYRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequestY struct {
	// Aggregator used for the request.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetScatterplotDefinitionRequestYApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetScatterplotDefinitionRequestYLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetScatterplotDefinitionRequestYProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetScatterplotDefinitionRequestYRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetScatterplotDefinitionRequestYSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
}

type DashboardSpecWidgetScatterplotDefinitionRequest struct {
	// The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
	// +optional
	X []DashboardSpecWidgetScatterplotDefinitionRequestX `json:"x,omitempty" tf:"x"`
	// The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
	// +optional
	Y []DashboardSpecWidgetScatterplotDefinitionRequestY `json:"y,omitempty" tf:"y"`
}

type DashboardSpecWidgetScatterplotDefinitionXaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetScatterplotDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetScatterplotDefinition struct {
	// List of groups used for colors.
	// +optional
	ColorByGroups []string `json:"colorByGroups,omitempty" tf:"color_by_groups"`
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetScatterplotDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
	// +optional
	Request *DashboardSpecWidgetScatterplotDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
	// +optional
	Xaxis *DashboardSpecWidgetScatterplotDefinitionXaxis `json:"xaxis,omitempty" tf:"xaxis"`
	// A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
	// +optional
	Yaxis *DashboardSpecWidgetScatterplotDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetServiceLevelObjectiveDefinition struct {
	// The global time target of the widget.
	// +optional
	GlobalTimeTarget *string `json:"globalTimeTarget,omitempty" tf:"global_time_target"`
	// Whether to show the error budget or not.
	// +optional
	ShowErrorBudget *bool `json:"showErrorBudget,omitempty" tf:"show_error_budget"`
	// The ID of the service level objective used by the widget.
	SloID *string `json:"sloID" tf:"slo_id"`
	// A list of time windows to display in the widget.
	TimeWindows []string `json:"timeWindows" tf:"time_windows"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// The view mode for the widget.
	ViewMode *string `json:"viewMode" tf:"view_mode"`
	// The type of view to use when displaying the widget. Only `detail` is supported.
	ViewType *string `json:"viewType" tf:"view_type"`
}

type DashboardSpecWidgetServicemapDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetServicemapDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetServicemapDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// Your environment and primary tag (or `*` if enabled for your account).
	Filters []string `json:"filters" tf:"filters"`
	// The ID of the service to map.
	Service *string `json:"service" tf:"service"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetTimeseriesDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetTimeseriesDefinitionEvent struct {
	// The event query to use in the widget.
	Q *string `json:"q" tf:"q"`
	// The execution method for multi-value filters.
	// +optional
	TagsExecution *string `json:"tagsExecution,omitempty" tf:"tags_execution"`
}

type DashboardSpecWidgetTimeseriesDefinitionMarker struct {
	// How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
	// +optional
	DisplayType *string `json:"displayType,omitempty" tf:"display_type"`
	// A label for the line or range.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
	Value *string `json:"value" tf:"value"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetTimeseriesDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetTimeseriesDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestMetadata struct {
	// The expression alias.
	// +optional
	AliasName *string `json:"aliasName,omitempty" tf:"alias_name"`
	// The expression name.
	Expression *string `json:"expression" tf:"expression"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetTimeseriesDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetTimeseriesDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetTimeseriesDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequestStyle struct {
	// The type of lines displayed.
	// +optional
	LineType *string `json:"lineType,omitempty" tf:"line_type"`
	// The width of line displayed.
	// +optional
	LineWidth *string `json:"lineWidth,omitempty" tf:"line_width"`
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetTimeseriesDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetTimeseriesDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetTimeseriesDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// How to display the marker lines.
	// +optional
	DisplayType *string `json:"displayType,omitempty" tf:"display_type"`
	// +optional
	Formula []DashboardSpecWidgetTimeseriesDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetTimeseriesDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
	// +optional
	Metadata []DashboardSpecWidgetTimeseriesDefinitionRequestMetadata `json:"metadata,omitempty" tf:"metadata"`
	// The query to use for this widget.
	// +optional
	NetworkQuery *DashboardSpecWidgetTimeseriesDefinitionRequestNetworkQuery `json:"networkQuery,omitempty" tf:"network_query"`
	// A Boolean indicating whether the request uses the right or left Y-Axis.
	// +optional
	OnRightYaxis *bool `json:"onRightYaxis,omitempty" tf:"on_right_yaxis"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetTimeseriesDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetTimeseriesDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetTimeseriesDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetTimeseriesDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// The style of the widget graph. Exactly one `style` block is allowed using the structure below.
	// +optional
	Style *DashboardSpecWidgetTimeseriesDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetTimeseriesDefinitionRightYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetTimeseriesDefinitionYaxis struct {
	// Always include zero or fit the axis to the data range.
	// +optional
	IncludeZero *bool `json:"includeZero,omitempty" tf:"include_zero"`
	// The label of the axis to display on the graph.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// Specify the maximum value to show on the Y-axis.
	// +optional
	Max *string `json:"max,omitempty" tf:"max"`
	// Specify the minimum value to show on the Y-axis.
	// +optional
	Min *string `json:"min,omitempty" tf:"min"`
	// Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
	// +optional
	Scale *string `json:"scale,omitempty" tf:"scale"`
}

type DashboardSpecWidgetTimeseriesDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetTimeseriesDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
	// +optional
	Event []DashboardSpecWidgetTimeseriesDefinitionEvent `json:"event,omitempty" tf:"event"`
	// A list of columns to display in the legend.
	// +optional
	LegendColumns []string `json:"legendColumns,omitempty" tf:"legend_columns"`
	// The layout of the legend displayed in the widget.
	// +optional
	LegendLayout *string `json:"legendLayout,omitempty" tf:"legend_layout"`
	// The size of the legend displayed in the widget.
	// +optional
	LegendSize *string `json:"legendSize,omitempty" tf:"legend_size"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
	// +optional
	Marker []DashboardSpecWidgetTimeseriesDefinitionMarker `json:"marker,omitempty" tf:"marker"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetTimeseriesDefinitionRequest `json:"request,omitempty" tf:"request"`
	// A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
	// +optional
	RightYaxis *DashboardSpecWidgetTimeseriesDefinitionRightYaxis `json:"rightYaxis,omitempty" tf:"right_yaxis"`
	// Whether or not to show the legend on this widget.
	// +optional
	ShowLegend *bool `json:"showLegend,omitempty" tf:"show_legend"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
	// A nested block describing the Y-Axis Controls. The structure of this block is described below
	// +optional
	Yaxis *DashboardSpecWidgetTimeseriesDefinitionYaxis `json:"yaxis,omitempty" tf:"yaxis"`
}

type DashboardSpecWidgetToplistDefinitionCustomLink struct {
	// The flag for toggling context menu link visibility.
	// +optional
	IsHidden *bool `json:"isHidden,omitempty" tf:"is_hidden"`
	// The label for the custom link URL.
	// +optional
	Label *string `json:"label,omitempty" tf:"label"`
	// The URL of the custom link.
	// +optional
	Link *string `json:"link,omitempty" tf:"link"`
	// The label id that refers to a context menu link item. When override_label is provided, the client request omits the label field.
	// +optional
	OverrideLabel *string `json:"overrideLabel,omitempty" tf:"override_label"`
}

type DashboardSpecWidgetToplistDefinitionRequestApmQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestApmQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestApmQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetToplistDefinitionRequestApmQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestApmQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestApmQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetToplistDefinitionRequestApmQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestApmQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetToplistDefinitionRequestApmQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestAuditQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestAuditQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestAuditQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestAuditQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetToplistDefinitionRequestAuditQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestAuditQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetToplistDefinitionRequestAuditQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetToplistDefinitionRequestFormulaConditionalFormats struct {
	// The comparator to use.
	Comparator *string `json:"comparator" tf:"comparator"`
	// The color palette to apply to the background, same values available as palette.
	// +optional
	CustomBgColor *string `json:"customBgColor,omitempty" tf:"custom_bg_color"`
	// The color palette to apply to the foreground, same values available as palette.
	// +optional
	CustomFgColor *string `json:"customFgColor,omitempty" tf:"custom_fg_color"`
	// Setting this to True hides values.
	// +optional
	HideValue *bool `json:"hideValue,omitempty" tf:"hide_value"`
	// Displays an image as the background.
	// +optional
	ImageURL *string `json:"imageURL,omitempty" tf:"image_url"`
	// The metric from the request to correlate with this conditional format.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// The color palette to apply.
	Palette *string `json:"palette" tf:"palette"`
	// Defines the displayed timeframe.
	// +optional
	Timeframe *string `json:"timeframe,omitempty" tf:"timeframe"`
	// A value for the comparator.
	Value *float64 `json:"value" tf:"value"`
}

type DashboardSpecWidgetToplistDefinitionRequestFormulaLimit struct {
	// The number of results to return
	// +optional
	Count *int64 `json:"count,omitempty" tf:"count"`
	// The direction of the sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestFormula struct {
	// An expression alias.
	// +optional
	Alias *string `json:"alias,omitempty" tf:"alias"`
	// A list of display modes for each table cell.
	// +optional
	CellDisplayMode *string `json:"cellDisplayMode,omitempty" tf:"cell_display_mode"`
	// Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetToplistDefinitionRequestFormulaConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// A string expression built from queries, formulas, and functions.
	FormulaExpression *string `json:"formulaExpression" tf:"formula_expression"`
	// The options for limiting results returned.
	// +optional
	Limit *DashboardSpecWidgetToplistDefinitionRequestFormulaLimit `json:"limit,omitempty" tf:"limit"`
}

type DashboardSpecWidgetToplistDefinitionRequestLogQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestLogQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestLogQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetToplistDefinitionRequestLogQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestLogQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestLogQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetToplistDefinitionRequestLogQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestLogQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetToplistDefinitionRequestLogQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestProcessQuery struct {
	// A list of processes.
	// +optional
	FilterBy []string `json:"filterBy,omitempty" tf:"filter_by"`
	// The max number of items in the filter list.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// Your chosen metric.
	Metric *string `json:"metric" tf:"metric"`
	// Your chosen search term.
	// +optional
	SearchBy *string `json:"searchBy,omitempty" tf:"search_by"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery struct {
	// The data source for APM Dependency Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Determines whether stats for upstream or downstream dependencies should be queried.
	// +optional
	IsUpstream *bool `json:"isUpstream,omitempty" tf:"is_upstream"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	OperationName *string `json:"operationName" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	ResourceName *string `json:"resourceName" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryApmResourceStatsQuery struct {
	// The data source for APM Resource Stats queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// APM Environment.
	Env *string `json:"env" tf:"env"`
	// Array of fields to group results by.
	// +optional
	GroupBy []string `json:"groupBy,omitempty" tf:"group_by"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// Name of operation on service.
	// +optional
	OperationName *string `json:"operationName,omitempty" tf:"operation_name"`
	// The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting_primary_tags_to_scope/#add-a-second-primary-tag-in-datadog.
	// +optional
	PrimaryTagName *string `json:"primaryTagName,omitempty" tf:"primary_tag_name"`
	// Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
	// +optional
	PrimaryTagValue *string `json:"primaryTagValue,omitempty" tf:"primary_tag_value"`
	// APM resource.
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// APM statistic.
	Stat *string `json:"stat" tf:"stat"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryCompute struct {
	// The aggregation methods for event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// A time interval in milliseconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
	// The measurable attribute to compute.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryGroupBySort struct {
	// The aggregation methods for the event platform queries.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The metric used for sorting group by results.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Direction of sort.
	// +optional
	Order *string `json:"order,omitempty" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryGroupBy struct {
	// The event facet.
	Facet *string `json:"facet" tf:"facet"`
	// The number of groups to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The options for sorting group by results.
	// +optional
	Sort *DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryGroupBySort `json:"sort,omitempty" tf:"sort"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryEventQuerySearch struct {
	// The events search string.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryEventQuery struct {
	// The compute options.
	Compute []DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryCompute `json:"compute" tf:"compute"`
	// The data source for event platform-based queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Group by options.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestQueryEventQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// An array of index names to query in the stream.
	// +optional
	Indexes []string `json:"indexes,omitempty" tf:"indexes"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The search options.
	// +optional
	Search *DashboardSpecWidgetToplistDefinitionRequestQueryEventQuerySearch `json:"search,omitempty" tf:"search"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryMetricQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for metrics queries.
	// +optional
	DataSource *string `json:"dataSource,omitempty" tf:"data_source"`
	// The name of the query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The metrics query definition.
	Query *string `json:"query" tf:"query"`
}

type DashboardSpecWidgetToplistDefinitionRequestQueryProcessQuery struct {
	// The aggregation methods available for metrics queries.
	// +optional
	Aggregator *string `json:"aggregator,omitempty" tf:"aggregator"`
	// The data source for process queries.
	DataSource *string `json:"dataSource" tf:"data_source"`
	// Whether to normalize the CPU percentages.
	// +optional
	IsNormalizedCPU *bool `json:"isNormalizedCPU,omitempty" tf:"is_normalized_cpu"`
	// The number of hits to return.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// The process metric name.
	Metric *string `json:"metric" tf:"metric"`
	// The name of query for use in formulas.
	Name *string `json:"name" tf:"name"`
	// The direction of the sort.
	// +optional
	Sort *string `json:"sort,omitempty" tf:"sort"`
	// An array of tags to filter by.
	// +optional
	TagFilters []string `json:"tagFilters,omitempty" tf:"tag_filters"`
	// The text to use as a filter.
	// +optional
	TextFilter *string `json:"textFilter,omitempty" tf:"text_filter"`
}

type DashboardSpecWidgetToplistDefinitionRequestQuery struct {
	// The APM Dependency Stats query using formulas and functions.
	// +optional
	ApmDependencyStatsQuery *DashboardSpecWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery `json:"apmDependencyStatsQuery,omitempty" tf:"apm_dependency_stats_query"`
	// The APM Resource Stats query using formulas and functions.
	// +optional
	ApmResourceStatsQuery *DashboardSpecWidgetToplistDefinitionRequestQueryApmResourceStatsQuery `json:"apmResourceStatsQuery,omitempty" tf:"apm_resource_stats_query"`
	// A timeseries formula and functions events query.
	// +optional
	EventQuery *DashboardSpecWidgetToplistDefinitionRequestQueryEventQuery `json:"eventQuery,omitempty" tf:"event_query"`
	// A timeseries formula and functions metrics query.
	// +optional
	MetricQuery *DashboardSpecWidgetToplistDefinitionRequestQueryMetricQuery `json:"metricQuery,omitempty" tf:"metric_query"`
	// The process query using formulas and functions.
	// +optional
	ProcessQuery *DashboardSpecWidgetToplistDefinitionRequestQueryProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestRumQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestRumQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestRumQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetToplistDefinitionRequestRumQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestRumQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestRumQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetToplistDefinitionRequestRumQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestRumQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetToplistDefinitionRequestRumQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestSecurityQueryComputeQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Widget sorting methods.
	Order *string `json:"order" tf:"order"`
}

type DashboardSpecWidgetToplistDefinitionRequestSecurityQueryGroupBy struct {
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// The maximum number of items in the group.
	// +optional
	Limit *int64 `json:"limit,omitempty" tf:"limit"`
	// A list of exactly one element describing the sort query to use.
	// +optional
	SortQuery *DashboardSpecWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery `json:"sortQuery,omitempty" tf:"sort_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestSecurityQueryMultiCompute struct {
	// The aggregation method.
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// The facet name.
	// +optional
	Facet *string `json:"facet,omitempty" tf:"facet"`
	// Define the time interval in seconds.
	// +optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type DashboardSpecWidgetToplistDefinitionRequestSecurityQuery struct {
	// `compute_query` or `multi_compute` is required. The map keys are listed below.
	// +optional
	ComputeQuery *DashboardSpecWidgetToplistDefinitionRequestSecurityQueryComputeQuery `json:"computeQuery,omitempty" tf:"compute_query"`
	// Multiple `group_by` blocks are allowed using the structure below.
	// +optional
	GroupBy []DashboardSpecWidgetToplistDefinitionRequestSecurityQueryGroupBy `json:"groupBy,omitempty" tf:"group_by"`
	// The name of the index to query.
	Index *string `json:"index" tf:"index"`
	// `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
	// +optional
	MultiCompute []DashboardSpecWidgetToplistDefinitionRequestSecurityQueryMultiCompute `json:"multiCompute,omitempty" tf:"multi_compute"`
	// The search query to use.
	// +optional
	SearchQuery *string `json:"searchQuery,omitempty" tf:"search_query"`
}

type DashboardSpecWidgetToplistDefinitionRequestStyle struct {
	// A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
	// +optional
	Palette *string `json:"palette,omitempty" tf:"palette"`
}

type DashboardSpecWidgetToplistDefinitionRequest struct {
	// The query to use for this widget.
	// +optional
	ApmQuery *DashboardSpecWidgetToplistDefinitionRequestApmQuery `json:"apmQuery,omitempty" tf:"apm_query"`
	// The query to use for this widget.
	// +optional
	AuditQuery *DashboardSpecWidgetToplistDefinitionRequestAuditQuery `json:"auditQuery,omitempty" tf:"audit_query"`
	// Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
	// +optional
	ConditionalFormats []DashboardSpecWidgetToplistDefinitionRequestConditionalFormats `json:"conditionalFormats,omitempty" tf:"conditional_formats"`
	// +optional
	Formula []DashboardSpecWidgetToplistDefinitionRequestFormula `json:"formula,omitempty" tf:"formula"`
	// The query to use for this widget.
	// +optional
	LogQuery *DashboardSpecWidgetToplistDefinitionRequestLogQuery `json:"logQuery,omitempty" tf:"log_query"`
	// The process query to use in the widget. The structure of this block is described below.
	// +optional
	ProcessQuery *DashboardSpecWidgetToplistDefinitionRequestProcessQuery `json:"processQuery,omitempty" tf:"process_query"`
	// The metric query to use for this widget.
	// +optional
	Q *string `json:"q,omitempty" tf:"q"`
	// +optional
	Query []DashboardSpecWidgetToplistDefinitionRequestQuery `json:"query,omitempty" tf:"query"`
	// The query to use for this widget.
	// +optional
	RumQuery *DashboardSpecWidgetToplistDefinitionRequestRumQuery `json:"rumQuery,omitempty" tf:"rum_query"`
	// The query to use for this widget.
	// +optional
	SecurityQuery *DashboardSpecWidgetToplistDefinitionRequestSecurityQuery `json:"securityQuery,omitempty" tf:"security_query"`
	// Define request for the widget's style.
	// +optional
	Style *DashboardSpecWidgetToplistDefinitionRequestStyle `json:"style,omitempty" tf:"style"`
}

type DashboardSpecWidgetToplistDefinition struct {
	// A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
	// +optional
	CustomLink []DashboardSpecWidgetToplistDefinitionCustomLink `json:"customLink,omitempty" tf:"custom_link"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
	// +optional
	Request []DashboardSpecWidgetToplistDefinitionRequest `json:"request,omitempty" tf:"request"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetTraceServiceDefinition struct {
	// The number of columns to display.
	// +optional
	DisplayFormat *string `json:"displayFormat,omitempty" tf:"display_format"`
	// APM environment.
	Env *string `json:"env" tf:"env"`
	// The timeframe to use when displaying the widget.
	// +optional
	LiveSpan *string `json:"liveSpan,omitempty" tf:"live_span"`
	// APM service.
	Service *string `json:"service" tf:"service"`
	// Whether to show the latency breakdown or not.
	// +optional
	ShowBreakdown *bool `json:"showBreakdown,omitempty" tf:"show_breakdown"`
	// Whether to show the latency distribution or not.
	// +optional
	ShowDistribution *bool `json:"showDistribution,omitempty" tf:"show_distribution"`
	// Whether to show the error metrics or not.
	// +optional
	ShowErrors *bool `json:"showErrors,omitempty" tf:"show_errors"`
	// Whether to show the hits metrics or not
	// +optional
	ShowHits *bool `json:"showHits,omitempty" tf:"show_hits"`
	// Whether to show the latency metrics or not.
	// +optional
	ShowLatency *bool `json:"showLatency,omitempty" tf:"show_latency"`
	// Whether to show the resource list or not.
	// +optional
	ShowResourceList *bool `json:"showResourceList,omitempty" tf:"show_resource_list"`
	// The size of the widget.
	// +optional
	SizeFormat *string `json:"sizeFormat,omitempty" tf:"size_format"`
	// APM span name
	SpanName *string `json:"spanName" tf:"span_name"`
	// The title of the widget.
	// +optional
	Title *string `json:"title,omitempty" tf:"title"`
	// The alignment of the widget's title.
	// +optional
	TitleAlign *string `json:"titleAlign,omitempty" tf:"title_align"`
	// The size of the widget's title (defaults to 16).
	// +optional
	TitleSize *string `json:"titleSize,omitempty" tf:"title_size"`
}

type DashboardSpecWidgetWidgetLayout struct {
	// The height of the widget.
	Height *int64 `json:"height" tf:"height"`
	// Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
	// +optional
	IsColumnBreak *bool `json:"isColumnBreak,omitempty" tf:"is_column_break"`
	// The width of the widget.
	Width *int64 `json:"width" tf:"width"`
	// The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
	X *int64 `json:"x" tf:"x"`
	// The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
	Y *int64 `json:"y" tf:"y"`
}

type DashboardSpecWidget struct {
	// The definition for a Alert Graph widget.
	// +optional
	AlertGraphDefinition *DashboardSpecWidgetAlertGraphDefinition `json:"alertGraphDefinition,omitempty" tf:"alert_graph_definition"`
	// The definition for a Alert Value widget.
	// +optional
	AlertValueDefinition *DashboardSpecWidgetAlertValueDefinition `json:"alertValueDefinition,omitempty" tf:"alert_value_definition"`
	// The definition for a Change widget.
	// +optional
	ChangeDefinition *DashboardSpecWidgetChangeDefinition `json:"changeDefinition,omitempty" tf:"change_definition"`
	// The definition for a Check Status widget.
	// +optional
	CheckStatusDefinition *DashboardSpecWidgetCheckStatusDefinition `json:"checkStatusDefinition,omitempty" tf:"check_status_definition"`
	// The definition for a Distribution widget.
	// +optional
	DistributionDefinition *DashboardSpecWidgetDistributionDefinition `json:"distributionDefinition,omitempty" tf:"distribution_definition"`
	// The definition for a Event Stream widget.
	// +optional
	EventStreamDefinition *DashboardSpecWidgetEventStreamDefinition `json:"eventStreamDefinition,omitempty" tf:"event_stream_definition"`
	// The definition for a Event Timeline widget.
	// +optional
	EventTimelineDefinition *DashboardSpecWidgetEventTimelineDefinition `json:"eventTimelineDefinition,omitempty" tf:"event_timeline_definition"`
	// The definition for a Free Text widget.
	// +optional
	FreeTextDefinition *DashboardSpecWidgetFreeTextDefinition `json:"freeTextDefinition,omitempty" tf:"free_text_definition"`
	// The definition for a Geomap widget.
	// +optional
	GeomapDefinition *DashboardSpecWidgetGeomapDefinition `json:"geomapDefinition,omitempty" tf:"geomap_definition"`
	// The definition for a Group widget.
	// +optional
	GroupDefinition *DashboardSpecWidgetGroupDefinition `json:"groupDefinition,omitempty" tf:"group_definition"`
	// The definition for a Heatmap widget.
	// +optional
	HeatmapDefinition *DashboardSpecWidgetHeatmapDefinition `json:"heatmapDefinition,omitempty" tf:"heatmap_definition"`
	// The definition for a Hostmap widget.
	// +optional
	HostmapDefinition *DashboardSpecWidgetHostmapDefinition `json:"hostmapDefinition,omitempty" tf:"hostmap_definition"`
	// The ID of the widget.
	// +optional
	ID *int64 `json:"ID,omitempty" tf:"id"`
	// The definition for an Iframe widget.
	// +optional
	IframeDefinition *DashboardSpecWidgetIframeDefinition `json:"iframeDefinition,omitempty" tf:"iframe_definition"`
	// The definition for an Image widget
	// +optional
	ImageDefinition *DashboardSpecWidgetImageDefinition `json:"imageDefinition,omitempty" tf:"image_definition"`
	// The definition for an Log Stream widget.
	// +optional
	LogStreamDefinition *DashboardSpecWidgetLogStreamDefinition `json:"logStreamDefinition,omitempty" tf:"log_stream_definition"`
	// The definition for an Manage Status widget.
	// +optional
	ManageStatusDefinition *DashboardSpecWidgetManageStatusDefinition `json:"manageStatusDefinition,omitempty" tf:"manage_status_definition"`
	// The definition for a Note widget.
	// +optional
	NoteDefinition *DashboardSpecWidgetNoteDefinition `json:"noteDefinition,omitempty" tf:"note_definition"`
	// The definition for a Query Table widget.
	// +optional
	QueryTableDefinition *DashboardSpecWidgetQueryTableDefinition `json:"queryTableDefinition,omitempty" tf:"query_table_definition"`
	// The definition for a Query Value widget.
	// +optional
	QueryValueDefinition *DashboardSpecWidgetQueryValueDefinition `json:"queryValueDefinition,omitempty" tf:"query_value_definition"`
	// The definition for a Scatterplot widget.
	// +optional
	ScatterplotDefinition *DashboardSpecWidgetScatterplotDefinition `json:"scatterplotDefinition,omitempty" tf:"scatterplot_definition"`
	// The definition for a Service Level Objective widget.
	// +optional
	ServiceLevelObjectiveDefinition *DashboardSpecWidgetServiceLevelObjectiveDefinition `json:"serviceLevelObjectiveDefinition,omitempty" tf:"service_level_objective_definition"`
	// The definition for a Service Map widget.
	// +optional
	ServicemapDefinition *DashboardSpecWidgetServicemapDefinition `json:"servicemapDefinition,omitempty" tf:"servicemap_definition"`
	// The definition for a Timeseries widget.
	// +optional
	TimeseriesDefinition *DashboardSpecWidgetTimeseriesDefinition `json:"timeseriesDefinition,omitempty" tf:"timeseries_definition"`
	// The definition for a Toplist widget.
	// +optional
	ToplistDefinition *DashboardSpecWidgetToplistDefinition `json:"toplistDefinition,omitempty" tf:"toplist_definition"`
	// The definition for a Trace Service widget.
	// +optional
	TraceServiceDefinition *DashboardSpecWidgetTraceServiceDefinition `json:"traceServiceDefinition,omitempty" tf:"trace_service_definition"`
	// The layout of the widget on a 'free' dashboard.
	// +optional
	WidgetLayout *DashboardSpecWidgetWidgetLayout `json:"widgetLayout,omitempty" tf:"widget_layout"`
}

type DashboardSpec struct {
	State *DashboardSpecResource `json:"state,omitempty" tf:"-"`

	Resource DashboardSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type DashboardSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// A list of dashboard lists this dashboard belongs to.
	// +optional
	DashboardLists []int64 `json:"dashboardLists,omitempty" tf:"dashboard_lists"`
	// A list of dashboard lists this dashboard should be removed from. Internal only.
	// +optional
	DashboardListsRemoved []int64 `json:"dashboardListsRemoved,omitempty" tf:"dashboard_lists_removed"`
	// The description of the dashboard.
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// Whether this dashboard is read-only.
	// +optional
	IsReadOnly *bool `json:"isReadOnly,omitempty" tf:"is_read_only"`
	// The layout type of the dashboard.
	LayoutType *string `json:"layoutType" tf:"layout_type"`
	// The list of handles for the users to notify when changes are made to this dashboard.
	// +optional
	NotifyList []string `json:"notifyList,omitempty" tf:"notify_list"`
	// The reflow type of a new dashboard layout. Set this only when layout type is `ordered`. If set to `fixed`, the dashboard expects all widgets to have a layout, and if it's set to `auto`, widgets should not have layouts.
	// +optional
	ReflowType *string `json:"reflowType,omitempty" tf:"reflow_type"`
	// Role UUIDs corresponding to users authorized to edit the dashboard. **This feature is currently in beta.**
	// +optional
	RestrictedRoles []string `json:"restrictedRoles,omitempty" tf:"restricted_roles"`
	// The list of template variables for this dashboard.
	// +optional
	TemplateVariable []DashboardSpecTemplateVariable `json:"templateVariable,omitempty" tf:"template_variable"`
	// The list of selectable template variable presets for this dashboard.
	// +optional
	TemplateVariablePreset []DashboardSpecTemplateVariablePreset `json:"templateVariablePreset,omitempty" tf:"template_variable_preset"`
	// The title of the dashboard.
	Title *string `json:"title" tf:"title"`
	// The URL of the dashboard.
	// +optional
	Url *string `json:"url,omitempty" tf:"url"`
	// The list of widgets to display on the dashboard.
	// +optional
	Widget []DashboardSpecWidget `json:"widget,omitempty" tf:"widget"`
}

type DashboardStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// DashboardList is a list of Dashboards
type DashboardList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Dashboard CRD objects
	Items []Dashboard `json:"items,omitempty"`
}
