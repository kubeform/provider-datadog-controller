/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type MonitoringRule struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitoringRuleSpec   `json:"spec,omitempty"`
	Status            MonitoringRuleStatus `json:"status,omitempty"`
}

type MonitoringRuleSpecCase struct {
	// A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
	// +optional
	Condition *string `json:"condition,omitempty" tf:"condition"`
	// Name of the case.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// Notification targets for each rule case.
	// +optional
	Notifications []string `json:"notifications,omitempty" tf:"notifications"`
	// Severity of the Security Signal.
	Status *string `json:"status" tf:"status"`
}

type MonitoringRuleSpecFilter struct {
	// The type of filtering action.
	Action *string `json:"action" tf:"action"`
	// Query for selecting logs to apply the filtering action.
	Query *string `json:"query" tf:"query"`
}

type MonitoringRuleSpecOptionsNewValueOptions struct {
	// The duration in days after which a learned value is forgotten.
	ForgetAfter *int64 `json:"forgetAfter" tf:"forget_after"`
	// The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
	LearningDuration *int64 `json:"learningDuration" tf:"learning_duration"`
}

type MonitoringRuleSpecOptions struct {
	// The detection method.
	// +optional
	DetectionMethod *string `json:"detectionMethod,omitempty" tf:"detection_method"`
	// A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
	EvaluationWindow *int64 `json:"evaluationWindow" tf:"evaluation_window"`
	// Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window.
	KeepAlive *int64 `json:"keepAlive" tf:"keep_alive"`
	// A signal will “close” regardless of the query being matched once the time exceeds the maximum duration. This time is calculated from the first seen timestamp.
	MaxSignalDuration *int64 `json:"maxSignalDuration" tf:"max_signal_duration"`
	// New value rules specific options.
	// +optional
	NewValueOptions *MonitoringRuleSpecOptionsNewValueOptions `json:"newValueOptions,omitempty" tf:"new_value_options"`
}

type MonitoringRuleSpecQuery struct {
	// The aggregation type.
	// +optional
	Aggregation *string `json:"aggregation,omitempty" tf:"aggregation"`
	// Field for which the cardinality is measured. Sent as an array.
	// +optional
	DistinctFields []string `json:"distinctFields,omitempty" tf:"distinct_fields"`
	// Fields to group by.
	// +optional
	GroupByFields []string `json:"groupByFields,omitempty" tf:"group_by_fields"`
	// The target field to aggregate over when using the sum or max aggregations.
	// +optional
	Metric *string `json:"metric,omitempty" tf:"metric"`
	// Name of the query.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// Query to run on logs.
	Query *string `json:"query" tf:"query"`
}

type MonitoringRuleSpec struct {
	State *MonitoringRuleSpecResource `json:"state,omitempty" tf:"-"`

	Resource MonitoringRuleSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type MonitoringRuleSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Cases for generating signals.
	// +kubebuilder:validation:MaxItems=5
	Case []MonitoringRuleSpecCase `json:"case" tf:"case"`
	// Whether the rule is enabled.
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// Additional queries to filter matched events before they are processed.
	// +optional
	Filter []MonitoringRuleSpecFilter `json:"filter,omitempty" tf:"filter"`
	// Whether the notifications include the triggering group-by values in their title.
	// +optional
	HasExtendedTitle *bool `json:"hasExtendedTitle,omitempty" tf:"has_extended_title"`
	// Message for generated signals.
	Message *string `json:"message" tf:"message"`
	// The name of the rule.
	Name *string `json:"name" tf:"name"`
	// Options on rules.
	// +optional
	Options *MonitoringRuleSpecOptions `json:"options,omitempty" tf:"options"`
	// Queries for selecting logs which are part of the rule.
	Query []MonitoringRuleSpecQuery `json:"query" tf:"query"`
	// Tags for generated signals.
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
}

type MonitoringRuleStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// MonitoringRuleList is a list of MonitoringRules
type MonitoringRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of MonitoringRule CRD objects
	Items []MonitoringRule `json:"items,omitempty"`
}
